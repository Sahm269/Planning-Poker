Pour que les bouton change de couleur quand on clik dessus

Dans jeu.blade.html
<div class="button-container">
    <button id="boutonRevoter" onclick="revoter()"> Aigain tache <i class="fa fa-spin"></i></button>
    <button id="boutonNextTache" onclick="nexttache()"> Next tache <i class="fa fa-forward"></i></button>
</div>

Dans copipoker.js

Fct revoter
document.getElementById('boutonRevoter').classList.add('bouton-clique');
Fct nexttache
document.getElementById('boutonNextTache').classList.add('bouton-clique');

Dans jeu.css
.bouton-clique {
    background-color: green;
    color: white;
}

------------------------------------

DANS COPIER POKER REMPLACER OU AJOUTER LE CODE EN DESSOUS

function mettreAJourTacheDebattre() {
    var tacheDebattreElement = document.getElementById('tacheDebattre');

    // Trouver la première tâche non encore débattue
    var tachesNonDebattues = Object.keys(partieData.backlog);
    var premierTache = tachesNonDebattues.length > 0 ? tachesNonDebattues[0] : null;

    console.log(premierTache);
    
    // Afficher la tâche à débattre dans l'interface
    if (premierTache !== null) {
        // Afficher la tâche dans l'interface
        tacheDebattreElement.textContent = premierTache;
    } else {
        tacheDebattreElement.textContent = "Aucune tâche restante";
        alert('La tâche est terminée!');
        ouvrirPopupFin('Planning poker finis !');
    }

}

function ouvrirPopupFin(description) {
    document.getElementById('finPartiePopUp').textContent = description;
    document.getElementById('overlay').style.display = 'block';
    document.getElementById('popupFin').style.display = 'block';
}

function fermerPopup() {
    // Fermer le popup et l'overlay
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('popupFin').style.display = 'none';
}

function quitter() {
    alert("Action quitter");
    enregistrer();
    fermerPopup('popupFin');
    window.location.href = '//profile.blade.php';
}

function nouvellePartie() {
    alert("Action créer une nouvelle partie");
    enregistrer();
    // Rediriger vers menu
    fermerPopup('popupFin');
    window.location.href = '//menu.blade.php';
}

function telechargerJson() {
    alert("Action télécharger le JSON");

    // Créer un lien de données (data URI) avec les données JSON encodées
    var lienTelechargement = document.createElement("a");
    lienTelechargement.href = 'data:application/json;charset=utf-8,' + encodeURIComponent(partieData.backlog);
    lienTelechargement.download = "backlog.json"; // Nom du fichier à télécharger

    // Ajouter le lien à la page et déclencher un clic
    document.body.appendChild(lienTelechargement);
    lienTelechargement.click();

    // Supprimer le lien après le téléchargement
    document.body.removeChild(lienTelechargement);

    enregistrer();

    fermerPopup('popupFin');

    //Rediriger vers une page ou faire un nouveau popup
}


// Fonction pour enregistrer la partie
function enregistrer() {
    var donneesAEnregistrer = {
        nomJoueur: partieData.nomJoueur,
        backlog: partieData.backlog,
        backlogRestantes: obtenirBacklog('backlogList'),
        backlogValidees: obtenirBacklog('backlogListvalide'),
        etatpartie: partieData.etatpartie,
        // Ajoutez d'autres propriétés au besoin
    };

    // Enregistrez les données dans le stockage local
    localStorage.setItem('donneesEnregistrees', JSON.stringify(donneesAEnregistrer));
}

---------------

DANS AFFICHAGE MENU

// Fonction pour récupérer la partie enregistrée
function recuperer() {
    var donneesEnregistrees = localStorage.getItem('donneesEnregistrees');
    if (donneesEnregistrees) {
        var donneesRestaurees = JSON.parse(donneesEnregistrees);

        partieData.nomJoueur = donneesRestaurees.nomJoueur;
        partieData.backlog = donneesRestaurees.backlog;
        partieData.etatpartie = donneesRestaurees.etatpartie;
        console.log("Partie récupérée:", donneesRestaurees);
        // Continuez la partie après la restauration
        continuerPartie();
    } else {
        console.log("Aucune donnée enregistrée trouvée.");
    }
}

---------------

JSP OU LA METTRE

function continuerPartie() {
    // Vérifier l'état actuel de la partie
    if (etat === 'finie') {
        alert('La partie est terminée!');
    } else {
        initialisation();
    }
}

ou ajouet etat en cours dans copie js 

---------------

DANS JEU.BLADE mettreAJourTacheDebattre

<div id="overlay"></div>
<div id="popupFin">
    <p id="finPartiePopUp"></p>
    <div class="bouton" id="bouton-quitter" onclick="quitter()">Quitter</div>
    <div class="bouton" id="bouton-new-partie" onclick="nouvellePartie()">Créer une nouvelle partie</div>
    <div class="bouton" id="bouton-telecharger" onclick="telechargerJson()">Télécharger le JSON</div>
</div>

<div class="bouton-container">
    <button type="button" class="bouton-quitter" onclick="ouvrirPopup('Quitter la partie')">Quitter</button>
    <button type="button" class="bouton-new-partie" onclick="ouvrirPopup('Créer une nouvelle partie')">Créer une nouvelle partie</button>
    <button type="button" class="bouton-telecharger" onclick="ouvrirPopup('Télécharger le JSON')">Télécharger le JSON</button>
</div>

-------------------------------------------

DANS JEU.CSS

<style>
    .carte-cafe {
        font-size: 0; /* Rendre la taille du texte zéro */
    }
</style>


<style>
    .carte {
        transition: transform 0.3s ease; /* Ajoute une transition à la propriété 'transform' sur 0.3 seconde avec une accélération régulière */
    }

    .carte:hover {
        transform: translateY(-5px); /* Déplace la carte vers le haut de 5 pixels lors du survol */
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3); /* Ajoute une ombre lors du survol */
    }

    .carte:not(:hover) {
        transform: translateY(0); /* Réinitialise la transformation lorsque la souris ne survole plus */
        box-shadow: none; /* Réinitialise l'ombre */
    }
</style>

--------------------------------------------


DANS COPIEPOKER SUPPRIMER TOUT CE QUI CONCERNE LE CHONOMETRE ET A LA PLACE METTRE 

//AU CHARGEMENT DE LA PAGE LANCE CHRONOMETTRE
document.addEventListener('DOMContentLoaded', function () {
    chronometre();
});

var compteReboursInterval;

var indexJoueurChrono=1;

function chronometre() {
    // Réinitialiser le temps restant
    var tempsRestant = 60;

    // Fonction pour mettre à jour le compte à rebours
    function mettreAJourCompteRebours() {
        var minutes = Math.floor(tempsRestant / 60);
        var secondes = tempsRestant % 60;

        // Affichage du compte à rebours dans votre élément HTML
        document.getElementById('chronometre').innerText = minutes + 'm ' + secondes + 's';

        // Vérification du compte à rebours
        if (tempsRestant <= 0) {
            clearInterval(compteReboursInterval);
            document.getElementById('chronometre').innerText = 'Temps écoulé';
            

        } else {
            tempsRestant--;
        }
    }

    // Effacer l'ancien intervalle s'il existe
    clearInterval(compteReboursInterval);

    // Définir le nouvel intervalle
    compteReboursInterval = setInterval(mettreAJourCompteRebours, 1000);

    // Retourner l'identifiant de l'intervalle
    return compteReboursInterval;
}

// Gestionnaire d'événements à chaque div de carte
for (let i = 0; i <= 12; i++) {
    // Supposons que vos div ont les identifiants de 'carte0' à 'carte12'
    var carteDiv = document.getElementById('carte' + i);
    // Gestionnaire d'événements à chaque div de carte
    carteDiv.addEventListener('click', function() {
        // Arrêter le chronomètre en utilisant l'identifiant de l'intervalle
        clearInterval(compteReboursInterval);
        if (indexJoueurChrono==ordreJoueurs.length){
            alert("Tous le monde a voté !");
            document.getElementById('chronometre').innerText = 'chronomètre';
        }
        else{
            // Redémarrer le chronomètre après un délai 2 secondes
            setTimeout(chronometre, 2000);
            alert("Passez le téléphone aux joueur suivant.");
            indexJoueurChrono++;
        }
    });
}

// Fonction pour réinitialiser les variables du chronomètre
function reinitialiserChronometre() {
    indexJoueurChrono= 1;
    chronometre();
}

// Gestionnaire d'événements pour le boutonNextTache
document.getElementById('boutonNextTache').addEventListener('click', function() {
    reinitialiserChronometre();
});


///////////////
var compteReboursInterval2;
function chronometre2() {
    // Réinitialiser le temps restant
    var tempsRestant2 = 180;

    // Fonction pour mettre à jour le compte à rebours
    function mettreAJourCompteRebours2() {
        var minutes2 = Math.floor(tempsRestant2 / 60);
        var secondes2 = tempsRestant2 % 60;

        // Affichage du compte à rebours dans votre élément HTML
        document.getElementById('chronometrevote').innerText = minutes2 + 'm ' + secondes2 + 's';

        // Vérification du compte à rebours
        if (tempsRestant2 <= 0) {
            clearInterval(compteReboursInterval2);
            document.getElementById('chronometrevote').innerText = 'Temps écoulé';
            // Ici du code à exécuter lorsque le temps est écoulé

        } else {
            tempsRestant2--;
        }
    }

    // Effacer l'ancien intervalle s'il existe
    clearInterval(compteReboursInterval2);

    // Définir le nouvel intervalle
    compteReboursInterval2 = setInterval(mettreAJourCompteRebours2, 1000);

    // Retourner l'identifiant de l'intervalle
    return compteReboursInterval2;
}

QUAND 
document.getElementById('discussion').style.display = 'block';
FAIRE
chronometre2();

DANS COPIEPOKER A LA FIN DE LA FONCTION VOTE AJOUTER
    // Vérifier si regleValue est égal à "majorite" avant d'attribuer l'estimation majoritaire à la tâche
    var regleValue = partieData.regle;
    if (regleValue === "majorite") {
        var estimationMajoritaire = trouverEstimationMajoritaire(partieData.nomJoueur);
        attribuerEstimationATache(estimationMajoritaire);
    }

DANS COPIEPOKER AJOUTER
function attribuerEstimationATache(estimation) {
    var tacheDebattreElement = document.getElementById('tacheDebattre');
    var tacheActuelle = tacheDebattreElement.textContent;
    // Attribution de l'estimation majoritaire à la tâche actuelle
    partieData.backlog[tacheActuelle] = estimation;
}

DANS COPIEPOKER AJOUTER
function trouverEstimationMajoritaire(estimations) {
    var maxVotes = 0;
    var carteMajoritaire = null;

    for (var estimation in estimations) {
        if (estimations.hasOwnProperty(estimation) && estimations[estimation] > maxVotes) {
            maxVotes = estimations[estimation];
            carteMajoritaire = estimation;
        }
    }
    return carteMajoritaire;
}

/////////////////////////////////

//variable globale compteur de vote
var compteurVotes = 0;

//dans reinitialiserVariables() ajoueter
function reinitialiserVariables() {
    compteurVotes = 0;
}

// Vérifier si le compteur de votes est supérieur à 1
if (compteurVotes > 1) {
    maxMajorite();
}

//dans la fonction vote au tout début
compteurVotes=0;

//dans la fonction vote après aficheminmax()
compteurVotes++;

////////////////////////////

// Fonction pour estimer la tâche en utilisant la stratégie appropriée
function estimerTache(regleValue, partieData) {
    var estimationStrategy;
  
    if (regleValue === 'strict') {
      estimationStrategy = new StrictEstimationStrategy();
    } else if (regleValue === 'majorite') {
      estimationStrategy = new MajorityEstimationStrategy();
    } else {
      // Stratégie par défaut ou gestion d'erreur si nécessaire
      estimationStrategy = new StrictEstimationStrategy();
    }
  
    // Utilisation de la stratégie pour effectuer l'estimation
    estimationStrategy.estimate(partieData);
  }
  
  // Classe de stratégie d'estimation de base
  class EstimationStrategy {
    estimate(partieData) {
      // Implémentation par défaut, peut être remplacée par des sous-classes
    }
  }
  
  // Classe de stratégie d'estimation pour la règle 'strict'
  class StrictEstimationStrategy extends EstimationStrategy {
    estimate(partieData) {
      // Code de base
  }
  
  // Classe de stratégie d'estimation pour la règle 'majorite'
  class MajorityEstimationStrategy extends EstimationStrategy {
    estimate(partieData) {
      maxMajorite(partieData);
    }
  }
  
  function maxMajorite(partieData) {
    //code de base
  }

  // Appel de la fonction principale pour estimer la tâche
  estimerTache(regleValue, partieData);
  